---
title: 初级
---
[[toc]]

## 一、JavaScript的变量有哪些类型？

分为两种：基础类型和引用类型。
- 基础类型（6种）：`boolean`、`null`、`undefined`、`number`、`string`、`symbol`。
- 引用类型：`Array`、`Object`、`Function`。`Array` 与 `Function` 都是基于 `Object`

## 二、基础类型和引用类型的区别？

- 它们在内存中存储的方式不同。基础类型存储的是值，而引用类型存储的是指向内存中某个空间的指针；
- 基础类型赋值就是把值赋给另外一个变量，而引用类型的赋值是赋值的原来变量的指针，所以当引用类型发生改变时，只要是指向同一个指针的变量的都会发生改变。

## 三、函数参数是对象时会发生什么问题？

函数参数是对象时，相当于是将对象的指针传递给了函数，如果在函数的内部改变了对象的值，外面对象的值也会发生改变，数组也是如此。

## 四、typeof和instanceof判断变量类型的区别？

- `typeof` 对于基础类型除了 `null` 以外都可以显示正确的类型，`null`会显示 `object`， 对于数组和对象都会显示 `object` ，对于函数会显示 `function` 。
- `instanceof` 主要是用来判断引用类型，它的原理是根据原型链来查找。

## 五、有没有更好的判断变量类型的方法？

可以使用 `Object.prototype.toString.call(var)` ，可以更加准确的判断某个变量的类型。

## 六、类数组转为数组的方式有哪些？

```javascript
[].slice.call(arguments)
Array.from(arguments)
[...arguments]
```
## 七、如何判断一个变量是否是数组？

```javascript
arr instanceof Array
Array.prototype.isPrototypeOf(arr)
Array.isArray(arr)
Object.prototype.toString.call(arr) === '[object Array]'
arr.constructor === Array
```

## 八、字符串的test、match、search它们之间的区别？

```javascript
// `test`是检测字符串是否匹配某个正则，返回布尔值；
/[a-z]/.test(1);  // false

// `match`是返回检测字符匹配正则的数组结果集合，没有返回`null`；
'1AbC2d'.match(/[a-z]/ig);  // ['A', 'b', 'C', 'd']

// `search`是返回正则匹配到的下标，没有返回`-1`。
'1AbC2d'.search(/[a-z]/);  // 2
```

## 九、字符串的slice、substring、substr它们之间的区别

```javascript
// `slice`是返回字符串开始至结束下标减去开始下标个数的新字符串，下标是负数为倒数；
'abcdefg'.slice(2,3);  // c  // 3 - 2
'abcdefg'.slice(3,2);  // ''  // 2 - 3
'abcdefg'.slice(-2,-1);  // f  // -1 - -2

// `substring`和`slice`正常截取字符串时相同，负数为0，且下标值小的为开始下标；
'abcdefg'.substring(2,3);  //c  // 3 - 2
'abcdefg'.substring(3,2);  // c  // 3 - 2 
'abcdefg'.substring(3,-3);  // abc  // 3 - 0

// `substr`返回开始下标开始加第二个参数(不能为负数)个数的新字符串。
'abcdefg'.substr(2, 3);  // cde
'abcdefg'.substr(3, 2);  // de
'abcdefg'.substr(-3, 2); // ef
```

## 十、Number('123')和new Number('123')有什么区别？

- `Number('123')` 是一个转换函数，会尝试把参数转为整数类型；
- 而 `new Number('123')` 则不同，这是一个构造函数，它的结果是实例化出来一个对象。
同样的情况也适用 `String` 和 `new String` `new Boolean` 和 `new Boolean` 的情况。

```javascript
typeof Number('123') // number
typeof new Number('123') // object
```

## 十一、==和===的区别？

`===` 会判断两边变量的类型和值是否全部相等，`==` 会存在变量类型转换的问题，所以并不推荐使用，只用一种情况会被使用，`var == null` 是 `var === undefined || var === null` 的简写，其余情况一律使用 `===`。

## 十二、是否===就完全靠谱？

不一定的，例如 `0 === -0` 就为 `true` ，`NaN === NaN` 为 `false` ，判断两个变量是否完全相等可以使用 `ES6` 新增的 `API` ，`Object.is(0, -0)` ，`Object.is(NaN, NaN)` 就可以准确区分。

## 十三、在类型转换中哪些值会被转为true？

除了 `undefined` 、 `null` 、 `false` 、 `NaN` 、 `''` 、 `0` 、 `-0` 以外的值都会被转为 `true` ，包括所有引用类型，即使是空的。

## 十四、什么是基本包装类型？

基本类型并不是对象，是不应该有各自方法的，为什么能调用各自的那些方法，是因为在后台对基本类型进行了包装。例如字符串、整数、布尔值，首先会使用各自的构造函数创建对应的实例，这样调用这些方法时就可以正常使用，不过再方法调用结束后，就会将实例给销毁掉，从而又是基本类型。

```javascript
let s1 = 'hello'
let s2 = s1.substring(2)
// ↓ 后台包装
let s1 = new String('hello') // 包装
let s2 = s1.substring(2) // 可以调用方法
s1 = null // 销毁
```

## 十五、toString()和valueOf的区别？

`null` 和 `undefined` 没有以上两个方法。
- `toString`：值类型时返回自身的字符串形式；当是引用类型时，无论是一维或多维数组，将他们拍平成一个字符串，里面的 `null` 和 `undefined` 转为空字符串 `''` ，对象转为 `[object Object]` ，函数的原样返回字符串形式。
- `valueOf` 无论是值类型还是引用类型，大部分情况下都是原样返回，当是 `Date` 类型时，返回时间戳。  
  
:::tip
在进行字符串强转的时候，`toString` 会优先于 `valueOf` ；在进行数值运算时，`valueOf` 会优先于 `toString` 。
当执行 `toString` 的变量是一个整数类型时，支持传参，表示需要转为多少进制的字符串。
:::

## 十六、谈谈对this的理解？

`this` 表示为当前的函数调用方，在运行时才能决定。如谁调用了某个方法，谁就是这个方法执行时的 `this` 。

## 十七、改变当前调用this的方式？

- `call` ：会立即执行调用 `call` 方法的函数，不过是以第一个参数为 `this` 的情况下调用，方法内可以传递不等的参数，作为调用 `call` 方法的参数。
- `apply` ：运行方式和 `call` 是一致的，只是接受的参数不同，不能是不定参数，得是一个数组。
- `bind` ：会改变当前的 `this` ，接受不定参数，不过不会马上执行调用 `bind` 方法的函数，而是返回一个函数作为结果，执行后才是调用函数的结果。

## 十八、谈谈对闭包的理解？

在 `JavaScript` 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

## 十九、谈谈对原型以及原型链的理解？

- 每一个 `JavaScript` 引用类型(数组/对象/函数)都有一个 `__proto__` 属性，这个属性是一个对象格式，也就是原型属性。在原型属性里面有一个 `constructor` 属性，这个属性是这个引用类型的构造函数，在 `constructor` 里面又有一个 `prototype` 的属性，这个属性又指回了引用类型的原型属性。
- 原型链就是通过对象的 `__proto__` 属性层层连接起来形成的，而构造函数的 `prototype` 是一个对象属性，再构造函数实例化时就会将这个属性赋值给实例化后对象的 `__proto__` 属性，所以函数的继承也会相应的构造出对象的原型链。

## 二十、原型继承的方式有哪些？

原型链继承、借用构造函数继承、组合继承、原型式继承、寄生组合继承等等。最优化的继承方式是寄生组合继承：

```javascript
function Parent(name) {
  this.name = name;
}
function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child
```

## 二十一、什么是垃圾回收机制？

- 在程序执行的过程中，解释器会为创建出来的变量分配内存来存储这些变量的实体，执行环境会负责管理代码执行过程中使用到的内存，而何时划出新的内存以及何时把占用的内存释放出来的这样一套内存自动管理机制就是垃圾回收机制。这种周期性的回收策略主要有两种。
- **标记清除**：当变量进入环境时，就将这个变量标记为'进入环境'，而当这个变量离开环境时，则将其标记为'离开环境'。垃圾收集器会给内存中的每个变量都做上标记，然后它会去掉环境中的变量以及被环境中变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，最后垃圾收集器完成内存清除工作。
- **引用计数**：追踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋给该变量时，这个变量的引用次数就是1。相反如果包含这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当为0时，这说明没有办法再访问这个值了，因此垃圾收集器下次运行时，就会释放该值占用的内存。

## 二十二、如何解决引用类型变量共享的问题？

可以对引用类型进行深拷贝解决，最简单暴力的深拷贝是 `JSON.parse(JSON.stringify(obj))` ，不过也会存在诸多问题，更加完善的深拷贝需要手写递归方法对不同参数分别处理。

## 二十三、函数防抖和节流的区别？

:::tip
函数防抖指一定时间内没有再次触发函数，就执行该函数，否则重新计时；节流是规定某个时间内只能执行一次函数。
:::
以wow（魔兽世界）为例：
- 函数防抖：2.5s施法的寒冰箭，再读条的过程中，你身子抖动打断了施法，再次触发技能时麻烦您重新读条。
- 函数节流：火冲为瞬发技能，不过你规定cd为8s，所以即使8s内按了10次，也只能来1发，节省点体力吧。

## 二十四、var、let、const的区别 ？
- `var` 类型会有变量提升的情况，也就是说声明会首先提升到当前作用域的顶端，在使用到时再读取定义的值。
- 在全局作用域下定义的 `var` 变量会挂载到作用域链的顶端 `window` 下，而 `let` 和 `const` 全局定义时在作用域链中要低一级。
- `let` 和 `const` 没有变量提升的情况，必须要先声明再使用，否则就会出现暂时性死区的情况。
- 而且它们的作用域存在最近的大括号之内，也就是块级作用域，并且一经定义后，同一个作用域内不能再次定义。
- 而 `const` 和 `let` 的区别在于一经定义后不得再次改变 `const` 定义的值，如果是引用类型只要不改变指针，改变里面的值是没问题的。
- `const` 定义时必须赋值，`let` 不必。

## 二十五、Set、WeakSet的区别？

- `Set` 类型内存储的是不会重复的值，建议存储基础类型的值，因为引用类型的指针都不同。
- `WeakSet` 只能存储对象参数，否则会报错，而且是存储的引用类型的弱引用。
- `WeakSet` 不可被迭代，不支持 `forEach` 、 `for-of` 、`keys` 、`values` 方法，没有 `size` 属性。

```js
const set = new Set();
const obj = {name: 'cc'};
set.add(obj);
obj = null;
[...set][0]; // {name: 'cc'} 转数组后依然可以访问到

const weakSet = new WeakSet();
const obj = {};
weakSet.add(obj);
obj = null;  // 会移除引用
weakSet.has(obj); // false
```

## 二十六、Map、WeakMap的区别？
- `Map` 是解决了对象 `key` 会被自动转为字符串的一种增强 `key/value` 集合。
- `WeakMap` 是弱引用的 `Map` 集合，`key` 必须是非 `null` 的对象格式，同样不可以被迭代。

```js
const obj = Object.create(null);
obj[1] = 'cc';
obj['1']; // cc

const map = new Map();
map.set(1, 'cc');
map.has('1');  // false   1 和 '1'不会被转换
```

## 二十七、箭头函数和普通函数的区别？

- 箭头函数的 `this` 是由包裹它的普通函数的 `this` 来决定；
- 不能作为构造函数,  `Generator` 函数；
- 参数不能使用 `arguments` 访问，需要使用 `Es6` 的不定参数访问；
- 使用 `bind` 方法无效。

## 二十八、谈谈对 `class` 的理解 ？

`JavaScript` 没有真正的类，一直也是通过函数加原型的形式来模拟，`class` 也不例外，只是语法糖，本质还是函数。需要先声明再使用，内部的方法不会被遍历，且没有函数的 `prototype` 属性。不过相较 `ES6` 之前无论是定义还是继承都好理解了很多。继承主要是使用 `extends` 和 `super` 关键字，本质类似于 `ES5` 的寄生组合继承：

```js
class Parent {
  constructor(name) {
    this.name = name;
  }
}
class Child extends Parent {
  constructor(name, age) {
    super(name);  // 相当于Parent.call(this, name)
    this.age = age;
  }
}
```

## 二十九、谈谈对Promise的理解 ？

- `Promise` 主要解决的问题就是异步回调嵌套过深造成代码难以维护和理解（回调地狱）。
- `Promise` 构造函数内的代码是同步执行的，而之后 `then` 或 `catch` 方法是异步执行的，构造函数接受两个函数参数 `resolve` 和 `reject`，它们执行时接受的参数分别会传递给 `then` 和 `catch` 表示成功的回调以及失败回调接受到的值。
- `Promise` 一共有三种状态 `pending` 等待状态、`resolved` 已完成状态、`rejected` 已拒绝状态，状态的改变只能由等待转为已完成或等待转为已拒绝状态，而且状态的改变只会发生一次。
- 必须要实现 `then` 方法且方法里必须要返回一个 `Promise` 对象，如果是返回其他的类型会尝试包装成 `Promise` 对象；
- `then` 可以被链式的调用。
- 缺点是 `Promise` 链中途无法取消；**错误需要通过回调函数捕获**。

## 三十、谈谈对ES-Module的理解？

`ES-Module` 是 `ES6` 原生支持模块化方案，通过 `import` 来引入模块，通过 `export default` 或 `export` 来导出模块。
## 三十一、谈谈对Proxy的理解 ？

和 `Object.defineProperty` 有些类似，它的作用是用来自定义对象中操作。`Proxy` 的构造函数接受两个参数，第一个参数是需要代理的对象，第二个参数是一个对象，里面会定义 `get` 和 `set` 方法，当代理对象中的某个值被访问或重新赋值就会触发相应的 `get` 和 `set` 方法。`vue3.0` 就抛弃了 `Object.defineProperty` 而拥抱了 `Proxy` ，它的优点是只需要代理一次，对象内的值发生了改变就会被感知到，不再需要像以前为对象的每个值进行数据劫持；而且以前对象的新增，数组的下标设置0清空等情况都可以被感知到，在响应式里也不在需要为数组和对象收集两次依赖，相信会大大提升性能。

## 三十二、谈谈对Generator的理解？

- 是 `JavaScript` 方便创建迭代器的新语法，在方法名前面添加 `*` 号，表示这个方法是一个生成器函数，在函数内部配合 `yield` 关键字指定 `next()` 方法返回值及顺序。
- `yield` 类似与在函数内部打上了断点，`yield` 就是每一处的 `debugger` ，执行 `next()` 方法后进入下一个断点。
- 不能使用箭头函数来创建生成器。

## 三十三、谈谈对async及await的理解 ？

是 `Genneator` 的语法糖形式，解决的问题是以同步的形式写异步代码，让代码流程能很好的表示执行流程。在函数的前面加上 `async` 表明是一个异步函数，函数的内部需要配合 `await` 关键字使用，每一个 `await` 关键字相当于是 `yield` ，会暂停函数的执行，直到异步函数执行完毕后内部会自动执行 `next()` 方法，执行之后的代码，函数的返回结果是一个 `Promise` 对象。因为是以同步的形式书写异步代码，所以错误捕获是使用 `try/catch` 的形式。

## 三十四、谈谈对Event-Loop的理解 ？

- `JavaScript` 的执行机制简单来说就先执行同步代码，然后执行异步代码，而异步的代码里面又分为宏任务代码和微任务代码，先执行微任务，然后执行宏任务。首先会将所有 `JavaScript` 作为一个宏任务执行，遇到同步的代码就执行，然后开始分配任务，遇到宏任务就将它的回调分配到宏任务的队列里，遇到微任务的回调就分配到微任务的队列里，然后开始执行所有的微任务。执行微任务的过程还是遵循先同步然后分配异步任务的顺序，微任务执行完毕之后，一次 `Event-Loop` 的 `Tick` 就算完成了。接着挨个去执行分配好的宏任务，在每个宏任务里又先同步后分配异步任务，完成下一次 `Tick` ，循环往复直到所有的任务全部执行完成。

- 微任务包括：`process.nextTick` ，`promise` ，`MutationObserver`。

- 宏任务包括：`script` ，`setTimeout` ，`setInterval` ，`setImmediate` ，`I/O` ，`UI rendering`。

## 三十五、对浏览器或元素的各种距离参数你知道哪些？
- `document.documentElement.clientHeight`：当前窗口内容区 + 内边距的高度
- `window.innerHeight`: 当前窗口内容区 + 内边距 + 边框 + 滚动条高度
- `window.outerHeight`：整个浏览器的高度(包括工具栏)
- `clientHeight`: 当前元素内容区 + 内边距的高度
- `clientTop`: 当前元素上边框的宽度
- `offsetHeight`: 当前元素内容区 + 内边距 + 边框 + 滚动条的高度
- `offsetTop`: 当前元素的边框距离父元素上外边距的距离
- `scrollHeight`: 当前内部可以滚动区域的高度，如果不能滚动则为自己内容区 + 内边距的高度
- `scrollTop`: 当前元素滚动离顶部的距离

## 三十六、怎么确定当前浏览器的类型？

通过 `navigator.userAgent` 获取浏览器信息，根据里面的关键字来确定。

## 三十七、什么是简单请求和复杂请求？
- 简单请求：
  - 请求方法仅限 `get、head、post`。
  - `Content-type` 仅限 `text/plain、multipart/form-data、application/x-www-form-urlencoded`。
- 复杂请求：
不符合以上条件者就为复杂请求，首先会发起一个 `option` 方法的预检请求，来知道服务端是否允许跨域请求。
有一个坑就是服务端设置了 `CORS` ，但当客户端发其复杂请求时会验证 `Authorization` 字段，但是客户端并没有，所以需要将 `option` 方法过滤掉。

## 三十八、从输入域名到页面显示都经历了什么？
首先将域名 `DNS` 解析为对应的 `IP` 地址，然后通过 `Socket` 发送数据，经过 `tcp` 协议的三次握手，向该地址发起 `HTTP` 请求，服务器处理，浏览器收到 `HTTP` 响应的数据，关闭 `tcp` 连接，开始渲染。

## 三十九、谈谈浏览器的渲染机制？
书写的 `JavaScript、Css、Html` 在网络传输中都是 **0和1** 的字节流，所以浏览器首先会把接受到的这些字节流转为字符串。然后首先将 `html` 字节流解析为字符串，对字符串进行标记化，确定标签名以及里面的内容，然后生成对应的 `node` 节点，根据节点的结构关系生成 `DOM树` 。然后开始解析 `css` ，和解析 `html` 类似，`css `一般有嵌套或继承的情况，浏览器会从里到外的递归来确定每个节点的样式是什么，从而生成一颗 `CSSOM树`。最后是将这两颗树结合起来生成一颗渲染树，浏览器根据渲染树进行布局，调用 `GPU` 绘制生成页面显示在屏幕上。

## 四十、什么是重绘和回流？

- 重绘是节点的外观发生改变而不改变布局时，如改变了 `color` 这个行为；回流是指改变布局或几何属性发生改变时引起的行为，如添加移除 `Dom`，改变尺寸。它们频繁的触发会影响页面性能。
- 回流一定触发重绘，而重绘不一定引起回流。回流的成本比重绘高很多，而且子节点的回流，可能引起父节点一系列的回流。

## 四十一、如何减少重绘和回流？

- 使用 `transform` 替代位移，使用 `translate3d` 开启 `GPU` 加速
- 尽量使用 `visibility` 替代 `display:none`
- 不要使用 `table` 布局
- 不要在循环里读取节点的属性值
- 动画速度越快，回流次数越少

## 四十二、什么是事件流/模型？
当某一个事件被触发时，分为三个阶段：
1. 事件通过捕获从`window` => `document` => `body` => `目标元素`
2. 事件到达注册的目标上
3. 目标元素通过冒泡返回到 `window`，沿途触发相同类型的事件

## 四十三、什么是事件代理？

利用事件流的冒泡特性，将子节点的事件绑定在父节点上，然后在回调里面使用事件对象进行区分，优点是节省内存且不需要给子节点销毁事件。

## 四十四、什么是事件对象？
这个对象里面存放着触发事件的状态，如触发事件的当前元素，键盘事件是哪个按键触发的，滚动事件的位置等等。

## 四十五、什么是跨域？
也就浏览器的同源策略，出于安全的考虑，只要是协议、域名、端口有一个不同就算是跨域，ajax请求就会失败。浏览器有同源策略主要是为了防止CSRF攻击，防止利用户的登录状态发起恶意请求。
## 四十六、你知道的解决跨域的方式有几种？
- `JSONP` ： 利用 `script` 标签不受同源策略限制，具体可以参考[40行封装一个jsonp包](https://juejin.im/post/6844903790760427528)。
- `CORS` ：使用自定义的 `HTTP头部` 让浏览器和服务器进行沟通，实现 `CORS` 的关键是后端，服务端设置 `Access-Control-Allow-Origin` 就可以开启，表示哪些域名可以访问资源。
- `document.domain` ：当二级域名相同时，例如 `a.test.html` 和 `b.test.html` ，只需要给两个页面都设置 `document.domain = 'test.html'` ，就可以实现跨域。
- `postMessage` ：如 `a.html` 页面通过 `iframe` 嵌入了 `b.html` 页面，其中一个可以通过 `postMessage` 方法发送信息，另一页面通过监听 `message` 事件判断来源并接受消息。
## 四十七、cookie和session分别是什么？有什么不同？

- `cookie` 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器发起请求时被携带并发送到服务器，它通常是告知服务端两个请求是否来自同一浏览器，保持用户的登录状态。
- `session` 代表着服务器在和客户端一次会话的过程，存储着用户会话所需的属性及配置信息，当用户在不同页面之间跳转时，使整个用户会话一直存在。
  
## 四十八、cookie和session有什么不同？
- 作用范围不同：`cookie` 存储在客户端，`session` 保存在服务器端。
- 存取的方式不同：`cookie` 只能保存 `ASCⅡ`，`session` 可以存取任意数据类型。
- 有效期不同：`cookie` 可设置长时间保持，`session` 一般失效时间较短，或客户端关闭就会失效。
- 存储大小不同：单个 `cookie` 保存的数据不能超过 `4k` ，`session` 可存储数据远高于 `cookie`。

## 四十九、为什么需要cookie和session？

让服务器知道根它打交道的用户是谁以及用户的状态，浏览器发起第一次请求后服务端会返回一个 `sessionID` 存储到 `cookie` 中，当再次发起请求时服务端根据携带的 `cookie` 里的 `sessionID` 来查找对应的 `session` 信息，没有找到就说明没登录或登录失效，找到说明已经登录，可以进行之后的操作。

## 五十、如果浏览器禁止了cookie怎么办？

每次请求都携带一个 `SessionID` 的参数；或者使用 `token` 令牌，登录后服务端生成一个 `Token` 返回给客户端，以后客户端携带 `token` 进行数据请求。

## 五十一、使用cookie有哪些注意点？
不建议作为存储方式使用。首先会随请求携带，影响请求的性能，其次存储空间也太小，最后一些属性的使用也需要注意。  
`value`：如果作用于登录状态，需要加密。  
`http-only`：不能通过 `JavaScript` 访问到 `cookie` ，防止 `XSS` 攻击。  
`same-site`：不能在跨域请求中携带 `cookie`，防止 `CSRF` 攻击。

## 五十二、前后端实现登录的方式有哪些？
- `cookie + session`：前端登录后，后端会种一个 `httpOnly` 的 `cookie` 在前端，里面就有这个用户对应的 `sessionId` ，以后每一次前端发起请求会携带上这个 `cookie` ，后端从里面解析到 `sessionId` 后找到对应的 `session` 信息，就知道是谁再操作了。缺点是后端需要空间存储 `session` ，用户多了，服务器多了都不方便，这种方式基本属于淘汰边缘。
- `jwt + token`：前端登录后，后端会返回一个包括用户信息加密的 `token` 字符串(可能还有过期时间，手机端有设备唯一码等信息)，客户端自己保存了，将这个 `token` 设置到 `header` 里的 `Authorization` ，之后每次请求都带上，服务器解码这个 `token` 之后就知道是谁在访问了。优点是不占存储空间，后端解码即可。

## 五十三、浏览器实现本地存储的方式有哪几种？

- `cookie`：存储大小 `4kb` ，会随请求发送到服务端，可设置过期时间。
- `localStorage`：存储大小为 `5M` ，不参与请求，除非被清理，否则一直存在。
- `sessionStorage`：存储大小为 `5M` ，不参与请求，页面关闭清除。
- `indexDB`：存储大小没限制，不参与请求，除非被清理，否则一直存在，运行在浏览器上的非关系型数据库。

## 五十四、了解Service Worker嘛？
是运行在浏览器背后的独立线程，可用于实现缓存功能，传输协议必须是 `HTTPS`。  
使用 `Service-Worker` 实现缓存功能一般分为三个步骤：首先注册，然后监听 `install` 事件缓存需要的文件，最后拦截请求事件，如果缓存中已经有请求的数据就直接使用。

## 五十五、谈谈对浏览器缓存的理解？

浏览器缓存是性能优化中最简单高效的一种，可以显著的减少网络传输所带来损耗，降低服务端压力。对于一个请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存就可以做到直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和缓存是一致的，就没必要传回来。

## 五十六、从哪些地方可以读取到浏览器缓存？

浏览器缓存会从四个位置去读取，并且它们是有优先级的，会依次去查找，最后都没有找到才会去发起请求。
- `Service Worker` ：和浏览器其他内建缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存且缓存是持续性的。
- `Memory Cache` ：从内存中读取，速度快，不过缓存的持续性并不高，关闭页面后内存中的缓存会被释放，什么东西能进内存确定不了。
- `Disk Cache` ：速度没有内存快，不过存储的容量和持续性会高很多，在浏览器缓存中硬盘的覆盖面是最大的。可以根据 `HTTP Header` 中的字段判断哪些资源需要缓存，哪些可以不请求直接使用，哪些已过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。
- `Push Cache` ：是 `HTTP/2` 中的内容，存储时间很短暂，只在会话中，一旦会话结束就被释放。
